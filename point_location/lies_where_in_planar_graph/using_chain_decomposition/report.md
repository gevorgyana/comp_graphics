Метою роботи алгоритма є побудова структури даних, яка
містить ланцюги, які визначають положення перевіюваної
точки у планарному графі. Пошук здійснюється у готовій
структурі, за наступною схемою. Ланцюги представлені
вузлами у бінарному дереві, яке будується за допомогою
нумерації як при обході за лівою стороною.

    Приклад

        4
     2     6
    1 3   5 7

Для обходу дерева у процесі пошуку необхідно знаходити
батьківський вузол, а також дочірні вузли для заданого
вузла x. Також треба знати, як рушити вліво та вправо від
поточного вузла.

Вхід алгоритму.
Набір точок у масиві типу Координата, які представляють вершини
графу, та ребра графу у вигляді сполучень вигляду.
(Індекс координати, Індекс координати).
Граф планарний та не містить точок, до яких не проведено сполучення
із деякої точки, яка знаходиться вище за неї.

Крок 1. O (кількість вхідних точок),
(викор. т. Ейлера, к-ть ребер є O(кількість вхідних точок),
сортування О(log (кількість вихідних точок)))

Відсортувати координати у порядку спадання за y-координатою, та
перетворити граф ребер.

Крок 2. Побудувати row та column-списки. Для кожної вершини, перший
список містить вказівники на усі вершини, які виходять із вершини,
другий містить вказівники на усі вершини, які закінчуються у даній
вершині. Також посортувати ребра у кожному зі списків, для кожної
вершини, за x-координатою.

Крок 3. Побудувати відображення weight[вершина], яке містить
кількість ребер, які виходять із верхньої вершини даного ребра.

Крок 4. Побудова структури даних для пошуку точки у графі. Маркування
регіонів у графі.
L та R - ліва та права позначки типу integer, які позначають регіони
зліва та справа для поточного ланцюга.

Алгоритм працює із точками за порядком спадання їх y-координат. Точки
мають бути посортовані за x як за другим ключем.

Для кожної точки, шукаємо різницю суми ваг вихідних ребер із даної
точки та суми ваг вхідних ребер для даної точки.

Підтримуємо індекс ланцюга, який є мінімальним таким, що містить
у собі точку, яка зараз розглядається.

Перерахунок його відбувається наступним чином.
На початку роботи 0, оскільки мінімальне ребро (у сенсі
його положення у дереві пошуку), яке містить верхню точку, має
індекс 0. А максимальне - індекс найвіддаленішого правого вузла.
Але ми підтримуємо тільки мінімальний індекс.

Насправді нам потрібно
розуміти мінімальний та максимальний індекс кожного ребра, яке виходить
із даної точки, перше значення буде співпадати зі значенням, яке ми
підтримуємо, а максимальний ланцюг знайдемо так: додамо до нього значення,
яке рівне кількості ребер, які покриваються усіма ланцюгами (для цього
потрібна різниця суми ваг усіх вихідниї ребер та усіх взідних ребер для даної
вершини), які містять поточне ребро.

Викоирстовуючи функцію пошуку найближчого
батьківського вузла у дереві для двох індексів, про які йде мова,
знаходимо індекс найпершого ланцюга, який містить поточне ребро.
Позначаємо цей звязок у структурі пошуку.

Після обробки останнього ребра запамятаємо індекс ланцюга, який
містить

При обробці кожного ребра також маркуємо область зліва та справа
від нього за допомогою цілих чисел.

    Приклад

         +
      0 /1\ 2
       +   \
             +

При роботі із ребрами будемо збільшувати значення поточного лівого регіону
по відношунню до даного ребра, та виставляти значення правого як на одиницю
бальше за значення лівого.

Після закінчення обробки усіх вершин (коли поставимо позначку 2 у даному
випадку), перейдемо до наступної точки (вершини).
Оскільки немає таких ребер, до яких не веде ребро із такої, що
знаходиться вище, то ми гарантовано записали для наступної точки, яку
будемо обробляти, мінімальне значення та максимальне значення ланцюгів, які
містять її (або, більш важливо, усі вихідні ребра тієї вершини),
а також позначили області зліва та справа від кожного ребра. Ці значення ми
підхопимо на наступному кроці.

Для пошуку візьмемо корінь дерева і будемо визначати, куди піти нижче
по ньому, за домогою звичайної процедури пошуку у бінарному дереві.
Зупинимося у листовому вузлі. При пошуку шукаємо проміжок, у який спустимося.
Для пошуку потрібно використовувати функції, які описані раніше.